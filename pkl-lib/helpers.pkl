/// Helper functions for common keyboard customization patterns
/// Provides high-level APIs for layers, app switching, and dual-function keys
module helpers

import "karabiner.pkl"

/// Valid key codes recognized by Karabiner-Elements
/// Based on official Karabiner-Elements documentation
const validKeyCodes: Set<String> = Set(
  // Letters (lowercase only)
  "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
  "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
  
  // Numbers
  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
  
  // Function keys
  "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12",
  "f13", "f14", "f15", "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23", "f24",
  
  // Special keys
  "escape", "return_or_enter", "tab", "spacebar", "hyphen", "equal_sign",
  "open_bracket", "close_bracket", "backslash", "non_us_pound", "semicolon",
  "quote", "grave_accent_and_tilde", "comma", "period", "slash", "non_us_backslash",
  
  // Lock keys
  "caps_lock", "scroll_lock", "num_lock",
  
  // Modifier keys
  "left_shift", "left_control", "left_option", "left_command",
  "right_shift", "right_control", "right_option", "right_command",
  "fn",
  
  // Arrow keys
  "up_arrow", "down_arrow", "left_arrow", "right_arrow",
  
  // Navigation keys
  "page_up", "page_down", "home", "end",
  
  // Delete keys
  "delete_or_backspace", "delete_forward",
  
  // System keys
  "print_screen", "pause", "insert",
  
  // Media keys
  "volume_up", "volume_down", "mute",
  "play", "stop", "rewind", "fast_forward",
  "brightness_up", "brightness_down",
  
  // Keypad
  "keypad_0", "keypad_1", "keypad_2", "keypad_3", "keypad_4",
  "keypad_5", "keypad_6", "keypad_7", "keypad_8", "keypad_9",
  "keypad_num_lock", "keypad_slash", "keypad_asterisk", "keypad_hyphen",
  "keypad_plus", "keypad_enter", "keypad_period", "keypad_equal_sign",
  "keypad_comma",
  
  // International keys
  "international1", "international2", "international3", "international4",
  "international5", "international6", "international7", "international8",
  "international9", "lang1", "lang2", "lang3", "lang4", "lang5",
  "lang6", "lang7", "lang8", "lang9",
  
  // Japanese keys
  "japanese_eisuu", "japanese_kana", "japanese_pc_nfer", "japanese_pc_xfer",
  "japanese_pc_katakana",
  
  // Other
  "help", "menu", "application", "power", "execute", "find", "select", "again",
  "undo", "cut", "copy", "paste", "find", "mute", "volume_up", "volume_down"
)

/// Validates that a key code is recognized by Karabiner-Elements
/// @param key The key code to validate
/// @return The validated key code
/// @throws Error if key code is invalid
function validateKeyCode(key: String): String = 
  if (!validKeyCodes.contains(key)) 
    throw("Invalid key code: '\(key)'. Key codes must be lowercase. Common issues: Use 'g' not 'G', 'shift' is a modifier not a key.")
  else key

/// Common key code constants for convenience
a = "a"
b = "b"
c = "c"
d = "d"
e = "e"
f = "f"
g = "g"
h = "h"
i = "i"
j = "j"
k = "k"
l = "l"
m = "m"
n = "n"
o = "o"
p = "p"
q = "q"
r = "r"
s = "s"
t = "t"
u = "u"
v = "v"
w = "w"
x = "x"
y = "y"
z = "z"

num0 = "0"
num1 = "1"
num2 = "2"
num3 = "3"
num4 = "4"
num5 = "5"
num6 = "6"
num7 = "7"
num8 = "8"
num9 = "9"

escape = "escape"
return_or_enter = "return_or_enter"
tab = "tab"
spacebar = "spacebar"
hyphen = "hyphen"
equal_sign = "equal_sign"
open_bracket = "open_bracket"
close_bracket = "close_bracket"
backslash = "backslash"
semicolon = "semicolon"
quote = "quote"
grave_accent_and_tilde = "grave_accent_and_tilde"
comma = "comma"
period = "period"
slash = "slash"
caps_lock = "caps_lock"
delete_or_backspace = "delete_or_backspace"
delete_forward = "delete_forward"

up_arrow = "up_arrow"
down_arrow = "down_arrow"
left_arrow = "left_arrow"
right_arrow = "right_arrow"

page_up = "page_up"
page_down = "page_down"
home = "home"
end = "end"

f1 = "f1"
f2 = "f2"
f3 = "f3"
f4 = "f4"
f5 = "f5"
f6 = "f6"
f7 = "f7"
f8 = "f8"
f9 = "f9"
f10 = "f10"
f11 = "f11"
f12 = "f12"

/// Creates a simple one-to-one key remapping
/// @param fromKey Key to remap from
/// @param toKey Key to remap to
/// @return SimpleModification for the remapping
function remap(fromKey: String, toKey: String): karabiner.SimpleModification = new {
  from = fromKey
  to = toKey
}

/// Creates a basic manipulator with optional modifiers
/// @param fromKey Key to trigger the mapping
/// @param toKey Key to output
/// @param modifiers Required modifier keys (e.g., ["left_command"])
/// @return Basic manipulator
function basic(
  fromKey: String, 
  toKey: String,
  modifiers: List<String>?
): karabiner.Manipulator = new {
  type = "basic"
  from = new karabiner.FromEvent {
    key_code = validateKeyCode(fromKey)
    modifiers = if (modifiers != null) new karabiner.Modifiers {
      mandatory = modifiers
    } else null
  }
  to = List(
    new karabiner.ToEvent {
      key_code = validateKeyCode(toKey)
    }
  )
}

/// Maps Caps Lock to Escape when tapped, Control when held
/// Common configuration for vim users
/// @return Rule for dual-function Caps Lock
function capsLockToEscapeControl(): karabiner.Rule = new {
  description = "Caps Lock to Escape when alone, Control when held"
  manipulators = List(
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        key_code = "caps_lock"
      }
      to = List(
        new karabiner.ToEvent {
          key_code = "right_control"
        }
      )
      to_if_alone = List(
        new karabiner.ToEvent {
          key_code = "escape"
        }
      )
    }
  )
}

/// Creates a layer activated by holding a modifier key
/// @param trigger Modifier key to activate layer (e.g., "left_control")
/// @param mappings Map of keys to their layer outputs
/// @param threshold Simultaneous threshold in milliseconds (default: 200)
/// @return Rule implementing the layer
/// @example layer("left_control", new Mapping { ["h"] = "left_arrow" })
function layer(
  trigger: String,
  mappings: Mapping<String, String | karabiner.ToEvent>,
  threshold: Int?
): karabiner.Rule = new {
  description = "Layer: \(trigger) + key"
  manipulators = mappings.toMap().entries.map((entry) -> 
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        key_code = validateKeyCode(entry.key)
        modifiers = new karabiner.Modifiers {
          mandatory = List(trigger)
        }
      }
      to = if (entry.value is String) List(
        new karabiner.ToEvent {
          key_code = validateKeyCode(entry.value as String)
        }
      ) else List(entry.value as karabiner.ToEvent)
      parameters = new karabiner.ManipulatorParameters {
        `basic.simultaneous_threshold_milliseconds` = threshold ?? 200
      }
    }
  )
}

/// Creates vim-style navigation bindings
/// @param modifierKey Modifier to activate (default: "left_control")
/// @return Rule with hjkl navigation and vim motions
function vimNavigation(modifierKey: String?): karabiner.Rule = 
  layer(modifierKey ?? "left_control", new Mapping {
    ["h"] = left_arrow
    ["j"] = down_arrow
    ["k"] = up_arrow
    ["l"] = right_arrow
    ["0"] = home
    ["4"] = end
    ["g"] = page_up
    ["d"] = delete_forward
    ["x"] = delete_or_backspace
  }, null)

/// Creates an app switcher layer
/// @param trigger Modifier key to activate switcher
/// @param apps Map of keys to application names
/// @return Rule for quick app switching
/// @example appSwitcher("right_command", new Mapping { ["s"] = "Safari" })
function appSwitcher(
  trigger: String,
  apps: Mapping<String, String>
): karabiner.Rule = new {
  description = "App Switcher: \(trigger) + key"
  manipulators = apps.toMap().entries.map((entry) ->
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        key_code = entry.key
        modifiers = new karabiner.Modifiers {
          mandatory = List(trigger)
        }
      }
      to = List(
        new karabiner.ToEvent {
          shell_command = "open -a '\(entry.value)'"
        }
      )
    }
  )
}

/// Creates a shift layer using simultaneous keys
/// Allows typing uppercase without holding shift
/// @param trigger Key to act as shift layer trigger
/// @return Rule implementing shift layer for a-z and 0-9
function shiftLayer(trigger: String): karabiner.Rule = new {
  description = "Shift Layer: \(trigger) + key"
  manipulators = charRange("a", "z").map((letter) ->
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        simultaneous = List(
          new karabiner.FromEvent { key_code = validateKeyCode(trigger) },
          new karabiner.FromEvent { key_code = validateKeyCode(letter) }
        )
        simultaneous_options = new karabiner.SimultaneousOptions {
          key_down_order = "strict"
          key_up_order = "strict_inverse"
          to_after_key_up = List(
            new karabiner.ToEvent { key_code = validateKeyCode(trigger) }
          )
        }
      }
      to = List(
        new karabiner.ToEvent {
          key_code = validateKeyCode(letter)
          modifiers = List("left_shift")
        }
      )
    }
  ) + numRange(0, 9).map((num) ->
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        simultaneous = List(
          new karabiner.FromEvent { key_code = validateKeyCode(trigger) },
          new karabiner.FromEvent { key_code = validateKeyCode(num) }
        )
        simultaneous_options = new karabiner.SimultaneousOptions {
          key_down_order = "strict"
          key_up_order = "strict_inverse"
          to_after_key_up = List(
            new karabiner.ToEvent { key_code = validateKeyCode(trigger) }
          )
        }
      }
      to = List(
        new karabiner.ToEvent {
          key_code = validateKeyCode(num)
          modifiers = List("left_shift")
        }
      )
    }
  )
}

/// Maps a key to Hyper (Cmd+Ctrl+Opt+Shift)
/// Useful for global shortcuts that won't conflict
/// @param trigger Key to convert to Hyper
/// @return Rule implementing Hyper key
function hyperKey(trigger: String): karabiner.Rule = new {
  description = "Hyper Key: \(trigger)"
  manipulators = List(
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        key_code = trigger
      }
      to = List(
        new karabiner.ToEvent {
          key_code = trigger
          modifiers = List(
            "left_command",
            "left_control",
            "left_option",
            "left_shift"
          )
        }
      )
    }
  )
}

/// Creates a manipulator to launch an application
/// @param key Trigger key
/// @param app Application name to launch
/// @param modifiers Optional modifier keys
/// @return Manipulator to open the app
function launchApp(key: String, app: String, modifiers: List<String>?): karabiner.Manipulator = new {
  type = "basic"
  from = new karabiner.FromEvent {
    key_code = key
    modifiers = if (modifiers != null) new karabiner.Modifiers {
      mandatory = modifiers
    } else null
  }
  to = List(
    new karabiner.ToEvent {
      shell_command = "open -a '\(app)'"
    }
  )
}

/// Space Mode - spacebar acts as a modifier when held
/// Spacebar still types space when tapped alone
/// @param mappings Keys available in space mode
/// @param threshold Simultaneous threshold (default: 200ms)
/// @return Rule implementing space mode
function spaceMode(
  mappings: Mapping<String, String | karabiner.ToEvent>,
  threshold: Int?
): karabiner.Rule = new {
  description = "Space Mode: Hold spacebar + key"
  manipulators = mappings.toMap().entries.map((entry) -> 
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        simultaneous = List(
          new karabiner.FromEvent { key_code = spacebar },
          new karabiner.FromEvent { key_code = entry.key }
        )
        simultaneous_options = new karabiner.SimultaneousOptions {
          key_down_order = "strict"
          key_up_order = "strict_inverse"
          to_after_key_up = List(
            new karabiner.ToEvent { key_code = spacebar }
          )
        }
      }
      to = if (entry.value is String) List(
        new karabiner.ToEvent {
          key_code = entry.value as String
        }
      ) else List(entry.value as karabiner.ToEvent)
      parameters = new karabiner.ManipulatorParameters {
        `basic.simultaneous_threshold_milliseconds` = threshold ?? 200
      }
    }
  )
}

/// Maps Caps Lock to Escape (simple version)
/// @return Rule for Caps Lock â†’ Escape
function capsLockToEscape(): karabiner.Rule = new {
  description = "Caps Lock to Escape"
  manipulators = List(
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        key_code = caps_lock
      }
      to = List(
        new karabiner.ToEvent {
          key_code = escape
        }
      )
    }
  )
}

/// Maps Caps Lock to modifier when held, Escape when tapped
/// @param modifier Modifier to use (default: "right_control")
/// @return Rule for dual-function Caps Lock
function capsLockToModifier(modifier: String?): karabiner.Rule = new {
  description = "Caps Lock to \(modifier ?? "right_control") when held, Escape when alone"
  manipulators = List(
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        key_code = caps_lock
      }
      to = List(
        new karabiner.ToEvent {
          key_code = modifier ?? "right_control"
        }
      )
      to_if_alone = List(
        new karabiner.ToEvent {
          key_code = escape
        }
      )
    }
  )
}

/// Generates a range of characters (a-z or 0-9)
/// @param start Starting character
/// @param end Ending character (inclusive)
/// @return List of characters in range
function charRange(start: String, end: String): List<String> = 
  let (alphabet = List("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"))
  let (digits = List("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"))
  let (allChars = if (digits.contains(start)) digits else alphabet)
  let (startIdx = allChars.indexOf(start))
  let (endIdx = allChars.indexOf(end))
  if (startIdx == -1 || endIdx == -1) throw("Invalid character range: \(start) to \(end)")
  else allChars.sublist(startIdx, endIdx + 1)

/// Generates a range of number strings
/// @param start Starting number
/// @param end Ending number (inclusive)
/// @return List of number strings
function numRange(start: Int, end: Int): List<String> = 
  IntSeq(start, end).toList().map((n) -> n.toString())

/// QWERTY keyboard layout rows for sequential key mappings
qwertyTopRow = List("q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "open_bracket", "close_bracket")
qwertyHomeRow = List("a", "s", "d", "f", "g", "h", "j", "k", "l", "semicolon", "quote")
qwertyBottomRow = List("z", "x", "c", "v", "b", "n", "m", "comma", "period", "slash")

/// Gets contiguous keys from QWERTY layout
/// @param startKey Starting key on keyboard
/// @param length Number of keys to include
/// @return List of sequential QWERTY keys
function qwertySequence(startKey: String, length: Int): List<String> = 
  let (allKeys = qwertyTopRow + qwertyHomeRow + qwertyBottomRow)
  let (startIdx = allKeys.indexOf(startKey))
  if (startIdx == -1) throw("Key \(startKey) not found in QWERTY layout")
  else if (startIdx + length > allKeys.length) allKeys.sublist(startIdx, allKeys.length)
  else allKeys.sublist(startIdx, startIdx + length)

/// Standard vim home row navigation mapping
/// @return Mapping of hjkl to arrow keys
function vimHomeRowNavigation(): Mapping<String, String> = new {
  ["h"] = left_arrow
  ["j"] = down_arrow
  ["k"] = up_arrow
  ["l"] = right_arrow
}

/// Simlayer - trigger key acts as layer when held with other keys
/// Uses simultaneous key detection for layer activation
/// @param trigger Key that activates the layer
/// @param mappings Layer key mappings
/// @param threshold Detection threshold (default: 200ms)
/// @return Rule implementing the simlayer
function simlayer(
  trigger: String,
  mappings: Mapping<String, String | karabiner.ToEvent>,
  threshold: Int?
): karabiner.Rule = new {
  description = "Simlayer: \(trigger) + key"
  manipulators = mappings.toMap().entries.map((entry) -> 
    new karabiner.Manipulator {
      type = "basic"
      from = new karabiner.FromEvent {
        simultaneous = List(
          new karabiner.FromEvent { key_code = validateKeyCode(trigger) },
          new karabiner.FromEvent { key_code = validateKeyCode(entry.key) }
        )
        simultaneous_options = new karabiner.SimultaneousOptions {
          key_down_order = "strict"
          key_up_order = "strict_inverse"
        }
      }
      to = if (entry.value is String) List(
        new karabiner.ToEvent {
          key_code = validateKeyCode(entry.value as String)
        }
      ) else List(entry.value as karabiner.ToEvent)
      parameters = new karabiner.ManipulatorParameters {
        `basic.simultaneous_threshold_milliseconds` = threshold ?? 200
      }
    }
  )
}

/// Creates a mapping of keys to their index positions (1-based)
/// Useful for creating focus space mappings with yabai
/// @param trigger Layer trigger key (unused but kept for API consistency)
/// @param keys List of keys to map
/// @return Mapping of keys to 1-based indices
function simlayerKeys(
  trigger: String,
  keys: List<String>
): Mapping<String, Int> = 
  new Mapping<String, Int> {
    ...keys.toMap((key) -> key, (key) -> keys.indexOf(key) + 1)
  }

/// Creates a list of KeyPress objects for the given keys
/// Used as trigger keys for simultaneous key detection
/// @param trigger Layer trigger key (unused but kept for API consistency)
/// @param keys List of key codes
/// @return List of KeyPress objects
function simlayerKeyPresses(
  trigger: String,
  keys: List<String>
): List<karabiner.KeyPress> = 
  keys.map((key) -> new karabiner.KeyPress {
    key_code = validateKeyCode(key)
  })

/// Creates a KeyPress with Hyper modifier (Cmd+Ctrl+Opt+Shift)
/// @param key Key to press with Hyper
/// @return KeyPress with all modifiers
function hyperkey(key: String): karabiner.KeyPress = new {
  key_code = validateKeyCode(key)
  modifiers = List(
    "left_command",
    "left_control",
    "left_option",
    "left_shift"
  )
}

/// Creates a KeyPress with Control modifier
/// @param key Key to press with Control
/// @return KeyPress with Control modifier
function ctrl(key: String): karabiner.KeyPress = new {
  key_code = validateKeyCode(key)
  modifiers = List("left_control")
}

/// Creates a range of number strings
/// @param start Starting number
/// @param end Ending number (inclusive)
/// @return List of number strings
function range(start: Int, end: Int): List<String> = 
  IntSeq(start, end).toList().map((n) -> n.toString())

/// Gets a range of keys from QWERTY layout
/// @param startKey Starting key
/// @param endKey Ending key (must come after startKey)
/// @return List of keys in QWERTY order
function qwertyRange(startKey: String, endKey: String): List<String> = 
  let (allKeys = qwertyTopRow + qwertyHomeRow + qwertyBottomRow)
  let (startIdx = allKeys.indexOf(startKey))
  let (endIdx = allKeys.indexOf(endKey))
  if (startIdx == -1) throw("Start key \(startKey) not found in QWERTY layout")
  else if (endIdx == -1) throw("End key \(endKey) not found in QWERTY layout")
  else if (startIdx > endIdx) throw("Invalid QWERTY range: \(startKey) comes after \(endKey)")
  else allKeys.sublist(startIdx, endIdx + 1)