module aerospace

import "karabiner.pkl"
import "core.pkl"
import "aerospace_actions.pkl"

cmdPath = "/opt/homebrew/bin/aerospace"

open class AerospaceMode {
  hidden ae: aerospace_actions.AerospaceActions = new aerospace_actions.AerospaceActions {}
  hidden actions = List("left", "down", "up", "right", "prev", "next", "first", "last")
  hidden modifier: (List<karabiner.Modifier> | karabiner.Modifier | String)?
  hidden mappings: Mapping<String, core.UserInput> = new Mapping {}
  hidden actionProvider: ((String) -> karabiner.ToEvent)
  hidden ignore = List("manipulators", "defined", "rules", "modifier", "actions", "ignore", "mappings", "actionProvider", "ae", "focusShouldFollow")

  function manipulators(): Map<String, core.Action> = 
    defined().entries.toMap((entry) -> if (entry.value is String) entry.value else entry.value.key_code , (entry) -> actionProvider.apply(entry.key))
  function defined() = toMap().filter((key, val) -> !(ignore.contains(key) || val is Null)) + this.mappings.toMap()
  function rules() = if (manipulators().isEmpty) null else new core.SimLayer {trigger = modifier; maps = manipulators().toMapping()}.build().last
  function build(parentModifier: (String | List<String>)?): karabiner.Rule? = 
    let (effectiveModifier = modifier ?? parentModifier)
    if (manipulators().isEmpty || effectiveModifier == null) null
    else new core.SimLayer {trigger = effectiveModifier; maps = manipulators().toMapping()}.build().last
}

open class Sequential extends AerospaceMode {
  prev: core.UserInput?
  next: core.UserInput?
  first: core.UserInput?
  last: core.UserInput?
}

open class Directional extends AerospaceMode {
  left: core.UserInput?
  down: core.UserInput?
  up: core.UserInput?
  right: core.UserInput?
  prev: core.UserInput?
  next: core.UserInput?
}

class WindowFocus extends Directional {
  dfsNext: core.UserInput?
  dfsPrev: core.UserInput?
  actionProvider = ae.window.focus.action
}

class WindowMove extends Directional {
  actionProvider = ae.window.move.action
}

class WindowResize extends AerospaceMode {
  width: core.UserInput?
  height: core.UserInput?
  smart: core.UserInput?
  smartOpposite: core.UserInput?
  amount: Int = 100
  actionProvider = ae.window.resize.action
}

class WindowLayout extends AerospaceMode {
  tiling: core.UserInput?
  floating: core.UserInput?
  hTiles: core.UserInput?
  vTiles: core.UserInput?
  fullscreen: core.UserInput?
  actionProvider = ae.window.layout.action
}

class WindowJoin extends Directional {
  actionProvider = ae.window.join.action
}

class WindowClose extends AerospaceMode {
  current: core.UserInput?
  allButCurrent: core.UserInput?
  actionProvider = ae.window.close.action
}

class WindowNative extends AerospaceMode {
  minimize: core.UserInput?
  fullscreen: core.UserInput?
  actionProvider = ae.window.native.action
}

class WorkspaceFocus extends Sequential {
  actionProvider = ae.workspace.focus.action
}

class WorkspaceMove extends Sequential {
  focusShouldFollow = true
  actionProvider = ae.workspace.move.action
}

class WorkspaceSummon extends Sequential {
  actionProvider = ae.workspace.summon.action
}

class WorkspaceTree extends AerospaceMode {
  flatten: core.UserInput?
  accordion: core.UserInput?
  actionProvider = ae.workspace.tree.action
}

class MonitorFocus extends Sequential {
  actionProvider = ae.monitor.focus.action
}

class MonitorMove extends Sequential {
  focusShouldFollow = true
  actionProvider = ae.monitor.move.action
}

class ModeBindings extends AerospaceMode {
  trigger: core.UserInput?
  bindings: Mapping<String, String> = new Mapping {}
  exitKey: String = "escape"
  actionProvider = ae.modes.resize.action
}

class Apps extends AerospaceMode {
  launchers: Mapping<String, String> = new Mapping {}
  actionProvider = ae.apps.launcher.action
}



class Triggers extends AerospaceMode {
  macros: Mapping<String, List<String>> = new Mapping {}
  actionProvider = ae.triggers.macros.action
}

open class AerospaceFeature {
  modifier: (String|List<String>)?
  function rules() = toMap().fold(List(), (acc, k, v) -> if (k == "modifier" || v?.rules() is Null) acc else acc.add(v.rules()))
  function build(parentModifier: (String | List<String>)?): List<karabiner.Rule> =
    let (effectiveModifier = modifier ?? parentModifier)
    toMap().fold(List(), (acc, k, v) ->
      if (k == "modifier" || v == null) acc
      else if (v is AerospaceMode)
        let (rule = v.build(effectiveModifier))
        if (rule == null) acc else acc.add(rule)
      else if (v is AerospaceFeature) acc + v.build(effectiveModifier)
      else acc
    )
}

class Window extends AerospaceFeature {
  focus: WindowFocus?
  move: WindowMove?
  resize: WindowResize?
  layout: WindowLayout?
  join: WindowJoin?
  close: WindowClose?
  native: WindowNative?
}

class Workspace extends AerospaceFeature {
  focus: WorkspaceFocus?
  move: WorkspaceMove?
  summon: WorkspaceSummon?
  tree: WorkspaceTree?
}

class Monitor extends AerospaceFeature {
  focus: MonitorFocus?
  move: MonitorMove?
}

class Modes extends AerospaceFeature {
  resize: ModeBindings?
  layout: ModeBindings?
  service: ModeBindings?
  custom1: ModeBindings?
  custom2: ModeBindings?
  custom3: ModeBindings?
}

class AeroSpace {
  modifier: (String | List<String>)? = null
  cmdPath: String = "/opt/homebrew/bin/aerospace"

  window: Window?
  workspace: Workspace?
  monitor: Monitor?
  modes: Modes?
  apps: Apps?
  triggers: Triggers?

  build: List<karabiner.Rule> =
    List(
      window?.build(modifier),
      workspace?.build(modifier),
      monitor?.build(modifier),
      modes?.build(modifier),
      apps?.build(modifier),
      triggers?.build(modifier)
    ).filterNonNull().flatten()
}
