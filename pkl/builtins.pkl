/// Built-in keyboard configuration helpers for common Karabiner-Elements patterns.
///
/// This module provides high-level helper functions that implement the most popular
/// and commonly requested keyboard modifications, based on community usage patterns
/// from the Karabiner-Elements ecosystem.
///
/// ## Available Helpers
///
/// - **Hyper Key**: Map a key to all four modifiers (⌃⌥⇧⌘) for global shortcuts
/// - **Symbol Layer**: Quick access to programming symbols without reaching for number row
/// - **Simultaneous Combos**: Build with `core.SimLayer`
/// - **Key Swaps**: Common key remapping presets
///
/// All functions return `karabiner.Rule` objects that can be added to your configuration's
/// rules list. These helpers are designed to be composable - you can combine multiple
/// helpers to create sophisticated keyboard layouts.
module builtins

import "karabiner.pkl"
import "core.pkl"
import "keys.pkl"

/// Creates a hyper key that maps a trigger key to all four modifiers (⌃⌥⇧⌘) when held.
///
/// The hyper key is one of the most popular Karabiner-Elements modifications. It allows
/// you to create global keyboard shortcuts that won't conflict with application shortcuts,
/// since no application uses all four modifiers simultaneously.
///
/// ## Example
/// ```pkl
/// // Caps Lock becomes hyper key
/// rules = List(builtins.hyperKey())
///
/// // Custom trigger key
/// rules = List(builtins.hyperKey(keys.right_command))
/// ```
///
/// ## Parameters
/// - `triggerKey`: The key to convert into a hyper key (default: caps_lock)
///
/// ## Returns
/// A `karabiner.Rule` that maps the trigger key to ⌃⌥⇧⌘ when held.
function hyperKey(triggerKey: core.UserInput?): karabiner.Rule =
  let (input = triggerKey ?? keys.caps_lock)
  let (k = new keys.Keys {})
  let (inputEvent = if (input is String) new karabiner.Event { key_code = input } else input)
  let (code = inputEvent.key_code)
  new core.BasicMap {
    key = input
    action = k.leftControl.and(k.leftOption.and(k.leftShift.and(k.leftCommand.and(inputEvent))))
  }.asRule("Hyper Key: \(code) to ⌃⌥⇧⌘")

/// Creates a dual-use hyper key that acts as ⌃⌥⇧⌘ when held with other keys,
/// and escape when tapped alone.
///
/// ## Example
/// ```pkl
/// // Caps Lock: hyper when held, escape when tapped
/// rules = List(builtins.hyperKeyDualUse())
///
/// // Custom key with dual behavior
/// rules = List(builtins.hyperKeyDualUse(keys.tab))
/// ```
///
/// ## Parameters
/// - `triggerKey`: The key to convert into a dual-use hyper key (default: caps_lock)
///
/// ## Returns
/// A `karabiner.Rule` with dual-use behavior: ⌃⌥⇧⌘ when held, escape when tapped.
function hyperKeyDualUse(triggerKey: core.UserInput?): karabiner.Rule =
  let (input = triggerKey ?? keys.caps_lock)
  let (k = new keys.Keys {})
  let (inputEvent = if (input is String) new karabiner.Event { key_code = input } else input)
  let (code = inputEvent.key_code)
  new core.DualUse {
    key = input
    hold = k.leftControl.and(k.leftOption.and(k.leftShift.and(k.leftCommand.and(inputEvent))))
    tap = keys.escape
  }.asRule("Dual-Use Hyper Key: \(code) to ⌃⌥⇧⌘/escape")

/// Creates a symbol layer for quick access to programming symbols and special characters.
///
/// When holding the trigger key, common letter keys are mapped to frequently used symbols,
/// eliminating the need to reach for the number row or use shift combinations. This is
/// especially popular among programmers and writers.
///
/// ## Default Mappings (when mappings is null)
/// | Key | Symbol | Key | Symbol | Key | Symbol |
/// |-----|--------|-----|--------|-----|--------|
/// | a   | _      | q   | !      | z   | <      |
/// | s   | -      | w   | @      | x   | >      |
/// | d   | =      | e   | #      | c   | `      |
/// | f   | +      | r   | $      | v   | "      |
/// | g   | *      | t   | %      | b   | '      |
/// | h   | (      | y   | ^      | ;   | {      |
/// | j   | )      | u   | &      | '   | }      |
/// | k   | \[    | i   | |      | p   | ~      |
/// | l   | \]    | o   | \\      |     |        |
///
/// ## Examples
/// ```pkl
/// // Default symbol layer with right shift
/// rules = List(builtins.symbolLayer(keys.right_shift))
/// ```
///
/// ## Parameters
/// - `triggerKey`: The key that activates the symbol layer when held
///
/// ## Returns
/// A `karabiner.Rule` that creates the symbol layer.
function symbolLayer(triggerKey: core.UserInput): karabiner.Rule =
  let (triggerEvent = if (triggerKey is String) new karabiner.Event { key_code = triggerKey } else triggerKey)
  let (triggerCode = triggerEvent.key_code ?? throw("symbolLayer trigger must provide a key code"))
  let (k = new keys.Keys {})

  let (mapping = new Mapping {
    [keys.a] = k.leftShift.and(k.hyphen)
    [keys.s] = k.hyphen
    [keys.d] = k.equalSign
    [keys.f] = k.leftShift.and(k.equalSign)
    [keys.g] = k.leftShift.and(k.eight)
    [keys.h] = k.leftShift.and(k.nine)
    [keys.j] = k.leftShift.and(k.zero)
    [keys.k] = k.openBracket
    [keys.l] = k.closeBracket
    [keys.semicolon] = k.leftShift.and(k.openBracket)
    [keys.quote] = k.leftShift.and(k.closeBracket)
    [keys.q] = k.leftShift.and(k.one)
    [keys.w] = k.leftShift.and(k.two)
    [keys.e] = k.leftShift.and(k.three)
    [keys.r] = k.leftShift.and(k.four)
    [keys.t] = k.leftShift.and(k.five)
    [keys.y] = k.leftShift.and(k.six)
    [keys.u] = k.leftShift.and(k.seven)
    [keys.i] = k.leftShift.and(k.backslash)
    [keys.o] = k.backslash
    [keys.p] = k.leftShift.and(k.graveAccentAndTilde)
    [keys.z] = k.leftShift.and(k.comma)
    [keys.x] = k.leftShift.and(k.period)
    [keys.c] = k.graveAccentAndTilde
    [keys.v] = k.leftShift.and(k.quote)
    [keys.b] = k.quote
  })

  let (ruleBuilder =
    if (karabiner.isMod(triggerCode))
      new core.Layer { modifier = triggerCode; mappings = mapping }
    else
      new core.SimLayer { trigger = triggerCode; maps = mapping }
  )

  let (rules = ruleBuilder.build())
  (rules.first) { description = "Symbol Layer (\(triggerCode))" }

/// Swaps the function of two keys with each other.
///
/// Key swapping is useful for personalizing your keyboard layout or fixing
/// keys that are in inconvenient positions. The swap is bidirectional.
///
/// ## Example
/// ```pkl
/// // Swap tab and escape keys
/// rules = List(builtins.swapKeys(keys.tab, keys.escape))
///
/// // Swap shift and control for ergonomics
/// rules = List(builtins.swapKeys(keys.left_shift, keys.left_control))
/// ```
///
/// ## Parameters
/// - `key1`: The first key to swap
/// - `key2`: The second key to swap
///
/// ## Returns
/// A `karabiner.Rule` that swaps the two keys.
function swapKeys(key1: core.UserInput, key2: core.UserInput): karabiner.Rule =
  let (code1 = if (key1 is String) key1 else key1.key_code)
  let (code2 = if (key2 is String) key2 else key2.key_code)
  new karabiner.Rule {
    description = "Swap: \(code1) ↔ \(code2)"
    manipulators = List(
      new core.BasicMap { key = key1; action = key2 },
      new core.BasicMap { key = key2; action = key1 }
    )
  }

/// Swaps semicolon and colon keys (semicolon without shift ↔ colon with shift).
///
/// This is one of the most popular key swaps, especially among programmers who
/// use colons more frequently than semicolons in many languages.
///
/// ## Example
/// ```pkl
/// rules = List(builtins.swapSemicolon())
/// ```
///
/// After applying this rule:
/// - Pressing `;` produces `:`
/// - Pressing `shift+;` produces `;`
///
/// ## Returns
/// A `karabiner.Rule` that swaps semicolon and colon.
function swapSemicolon(): karabiner.Rule =
  let (k = new keys.Keys {})
  new karabiner.Rule {
    description = "Swap: semicolon ↔ colon"
    manipulators = List(
      new core.BasicMap {
        key = keys.semicolon
        action = k.leftShift.and(k.semicolon)
      },
      new core.BasicMap {
        key = keys.semicolon
        mod = keys.left_shift
        action = keys.semicolon
      }
    )
  }
