module karabiner

import "core_types.pkl"
import "karabiner.pkl"

class Config {
  title: String = "Karabiner-Pkl Configuration"
  profiles: List<Profile> = List(
    new Profile {
      name = "pkl"
      selected = true
    }
  )
  global: Global?
}

class Global {
  check_for_updates_on_startup: Boolean = true
  show_in_menu_bar: Boolean = true
  show_profile_name_in_menu_bar: Boolean = false
}

class Profile {
  name: String
  selected: Boolean = false
  virtual_hid_keyboard: VirtualHidKeyboard?
  devices: List<Device> = List()
  fn_function_keys: List<FnFunctionKey> = List()
  simple_modifications: List<SimpleModification> = List()
  complex_modifications: ComplexModifications?
  parameters: Parameters?
}

class VirtualHidKeyboard {
  country_code: Int = 0
  indicate_sticky_modifier_keys_state: Boolean = true
  mouse_key_xy_scale: Int = 100
  keyboard_type_v2: KeyboardType = "ansi"
}

class Device {
  identifiers: DeviceIdentifiers
  ignore: Boolean = false
  disable_built_in_keyboard_if_exists: Boolean = false
  fn_function_keys: List<FnFunctionKey> = List()
  simple_modifications: List<SimpleModification> = List()
  manipulate_caps_lock_led: Boolean = false
}

class DeviceIdentifiers {
  vendor_id: Int
  product_id: Int
  is_keyboard: Boolean = true
  is_pointing_device: Boolean = false
}

class FnFunctionKey {
  from: KeyCode
  to: List<ToEvent>
}

class SimpleModification {
  from: KeyCode
  to: KeyCode
}

class ComplexModifications {
  parameters: ComplexModificationParameters?
  rules: List<Rule>
}

class ComplexModificationParameters {
  `basic.simultaneous_threshold_milliseconds`: Int = 50
  `basic.to_delayed_action_delay_milliseconds`: Int = 500
  `basic.to_if_alone_timeout_milliseconds`: Int = 1000
  `basic.to_if_held_down_threshold_milliseconds`: Int = 500
}

open class Rule {
  description: String
  manipulators: List<Manipulator>
}




open class Manipulator {
  type: ManipulatorType = "basic"
  from: FromEvent
  to: List<ToEvent>?
  to_if_alone: List<ToEvent>?
  to_after_key_up: List<ToEvent>?
  to_delayed_action: DelayedAction?
  conditions: List<Condition>?
  parameters: ManipulatorParameters?
}

typealias ManipulatorType = "basic" | "mouse_motion_to_scroll"


open class Event {
  key_code: KeyCode?
  modifiers: Modifiers?
  consumer_key_code: ConsumerKeyCode?

  function addModifier(other: Modifier) = (this) {modifiers = (outer.modifiers ?? List()).add(other)}

  hidden as_action: ToEvent = this.toDynamic().toTyped(ToEvent)
  hidden as_input: FromEvent = this.toDynamic().toTyped(FromEvent)
  hidden isMod = karabiner.isMod(key_code)
  hidden keyAsModifier = if (isMod) addModifier(key_code) else throw("Key need to be a modifier")
  hidden hasMod = modifiers.ifNonNull((it) -> !it.isEmpty) ?? false

  function and(other: Event) = if (other.isMod) other.addModifier(key_code) else (keyAsModifier) {key_code = other.key_code}

}


class FromEvent extends Event{
  pointing_button: PointingButton?
  simultaneous: List<FromEvent>?
  simultaneous_options: SimultaneousOptions?
}

class ToEvent extends Event{
  pointing_button: PointingButton?
  shell_command: String?
  select_input_source: InputSource?
  set_variable: SetVariable?
  mouse_key: MouseKey?
  sticky_modifier: StickyModifier?
  lazy: Boolean?
  repeat: Boolean?
  halt: Boolean?
  hold_down_milliseconds: Int?

  function withNotification(message: String): List<ToEvent> = List(this, new ToEvent { shell_command = "osascript -e 'display notification \"\(message)\" with title \"Karabiner\"'" })
  function build() = List(this)

}

class DelayedAction {
  to_if_invoked: List<ToEvent>
  to_if_canceled: List<ToEvent>
}

class Condition {
  type: ConditionType
  bundle_identifiers: List<String>?
  file_paths: List<String>?
  input_source_id: String?
  input_source_language: String?
  keyboard_types: List<KeyboardType>?
  name: String?
  value: Int | String | Boolean?
}

typealias ConditionType = "frontmost_application_if" | "frontmost_application_unless" | "device_if" | "device_unless" | "keyboard_type_if" | "keyboard_type_unless" | "input_source_if" | "input_source_unless" | "variable_if" | "variable_unless"

typealias KeyboardType = "ansi" | "iso" | "jis"


typealias Modifier = "caps_lock" | "left_command" | "left_control" | "left_option" | "left_shift" | "right_command" | "right_control" | "right_option" | "right_shift" | "fn" | "command" | "control" | "option" | "shift" | "any"
typealias Modifiers = List<Modifier>
function isMod(e)  = List("caps_lock" , "left_command" , "left_control" , "left_option" , "left_shift" , "right_command" , "right_control" , "right_option" , "right_shift" , "fn" , "command" , "control" , "option" , "shift" , "any").contains(e)
mods  = new Listing {"caps_lock" ; "left_command" }

class SimultaneousOptions {
  detect_key_down_uninterruptedly: Boolean? = false
  key_down_order: "insensitive" | "strict" | "strict_inverse" = "strict"
  key_up_order: "insensitive" | "strict" | "strict_inverse" = "strict_inverse"
  key_up_when: "any" | "all" = "any"
  to_after_key_up: List<ToEvent>?
}

class InputSource {
  language: String?
  input_source_id: String?
  input_mode_id: String?
}

class SetVariable {
  name: String
  value: String | Int | Boolean
}

class MouseKey {
  x: Int?
  y: Int?
  vertical_wheel: Int?
  horizontal_wheel: Int?
  speed_multiplier: Float?
}

class StickyModifier {
  modifier: Modifier
}

class ManipulatorParameters {
  `basic.simultaneous_threshold_milliseconds`: Int?
  `basic.to_delayed_action_delay_milliseconds`: Int?
  `basic.to_if_alone_timeout_milliseconds`: Int?
  `basic.to_if_held_down_threshold_milliseconds`: Int?
  `mouse_motion_to_scroll.speed`: Int?
}

class Parameters {
  delay_milliseconds_before_open_device: Int = 1000
}

typealias KeyCode = String
typealias ConsumerKeyCode = String
typealias PointingButton = String

