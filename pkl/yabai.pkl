module yabai

import "karabiner.pkl"
import "core.pkl"
import "yabai_actions.pkl"




cmdPath = "/opt/homebrew/bin/yabai"


open class YabaiMode {
  hidden ya: yabai_actions.YabaiActions = new yabai_actions.YabaiActions {}
  hidden actions = List("west", "south", "north", "east", "recent", "prev", "next", "first", "last")
  hidden modifier: (List<karabiner.Modifier> | karabiner.Modifier | String)?
  hidden mappings: Mapping<String, core.UserInput> = new Mapping {}
  hidden actionProvider: ((String) -> karabiner.ToEvent)
  hidden ignore = List("manipulators", "defined", "rules", "modifier", "mod", "actions", "ignore", "mappings", "actionProvider", "ya")

  function manipulators(): Map<String, core.Action>  = 
    defined().entries.toMap((entry) -> if (entry.value is String) entry.value else entry.value.key_code , (entry) -> actionProvider.apply(entry.key))
  function defined() = toMap().filter((key, val) -> !(ignore.contains(key) || val is Null)) + this.mappings.toMap()
  function rules() = if (manipulators().isEmpty) null else new core.SimLayer {trigger = modifier; maps = manipulators().toMapping()}.build().last
  function build(parentModifier: (String | List<String>)?): karabiner.Rule? =
    let (effectiveModifier = modifier ?? parentModifier)
    if (manipulators().isEmpty || effectiveModifier == null) null
    else if (effectiveModifier is List) new core.Layer {modifier = effectiveModifier; mappings = manipulators().toMapping()}.build().last
    else new core.SimLayer {trigger = effectiveModifier; maps = manipulators().toMapping()}.build().last
}

open class Sequential extends YabaiMode {
  prev: core.UserInput?
  next: core.UserInput?
  recent: core.UserInput?
  first: core.UserInput?
  last: core.UserInput?
}

open class Directional extends YabaiMode {
  east: core.UserInput?
  west: core.UserInput?
  north: core.UserInput?
  south: core.UserInput?
  prev: core.UserInput?
  next: core.UserInput?
}

open class DirectionalAction extends Directional {

}

class WindowFocus extends Directional {
  mouse: String?
  actionProvider =  ya.window.focus.action
}

class WindowSwap extends Directional {
  actionProvider = ya.window.swap.action
}

class WindowWarp extends Sequential {
  actionProvider =  ya.window.swap.action
}

class WindowResize extends Directional{
  actionProvider =  ya.window.swap.action
  left: String?
  down: String?
  up: String?
  right: String?
  topLeft: String?
  topRight: String?
  bottomLeft: String?
  bottomRight: String?
  increase: String?
  decrease: String?
  equalize: String?
  // amount: Int = 50
}

class WindowMoveFloat extends YabaiMode {
  actionProvider =  ya.window.move.action
  left: String?
  down: String?
  up: String?
  right: String?
  center: String?
  // amount: Int = 50
}

class WindowInsert extends Directional{
  actionProvider =  ya.window.swap.action
  stack: String?
  cancel: String?

}

class SpaceFocus extends Sequential {
  actionProvider = ya.space.focus.action
}

class SpaceMove extends Sequential {
  actionProvider =  ya.window.swap.action
}

class SpaceLayout extends YabaiMode {
  actionProvider =  ya.window.swap.action
  bsp: String?
  float: String?
  stack: String?
  balance: String?
  rotate: String?
  mirrorX: String?
  mirrorY: String?
}

class DisplayFocus extends Sequential {
  actionProvider =  ya.window.swap.action
}

class DisplayMove extends Sequential {
  actionProvider = (target) -> ya.display
}

class StackFocus extends Sequential {
  actionProvider =  ya.stack.focus.action
}

class StackSwap extends Sequential {
  actionProvider =  ya.stack.swap.action
}


open class YabaiFeature {
  modifier: (String|List<String>)?
  function rules() = toMap().fold(List(), (acc, k, v) -> if (k == "modifier" ||  v?.rules() is Null) acc else acc.add(v.rules()))
  function build(parentModifier: (String | List<String>)?): List<karabiner.Rule> = 
    let (effectiveModifier = modifier ?? parentModifier)
    toMap().fold(List(), (acc, k, v) -> 
      if (k == "modifier" || v == null) acc
      else if (v is YabaiMode) 
        let (rule = v.build(effectiveModifier))
        if (rule == null) acc else acc.add(rule)
      else if (v is YabaiFeature) acc + v.build(effectiveModifier)
      else acc
    )
}

class Window extends YabaiFeature {
  focus: WindowFocus?
  swap: WindowSwap?
  warp: WindowWarp?
  resize: WindowResize?
  moveFloat: WindowMoveFloat?
  insert: WindowInsert?

}

class Space extends YabaiFeature {
  focus: SpaceFocus?
  move: SpaceMove?
  layout: SpaceLayout?
}

class Display extends YabaiFeature {
  focus: DisplayFocus?
  move: DisplayMove?
}

class Toggles extends YabaiMode{
  actionProvider = (prop) -> ya.window.toggle.getProperty(prop)
  float: String?
  sticky: String?
  zoom: String?
  fullscreen: String?
  nativeFullscreen: String?
  split: String?
  minimize: String?
  gap: String?
  padding: String?
  topmost: String?
  pip: String?
  shadow: String?
  border: String?
  
  }

class Stack extends YabaiFeature {
  focus: StackFocus?
  swap: StackSwap?
}

class Yabai {
  modifier: (String | List<String>)? = null
  mod = modifier ?? ""

  window: Window?
  space: Space?
  display: Display?
  toggles: Toggles?
  stack: Stack?

  build: List<karabiner.Rule> =
    (window?.build(modifier) ?? List()) +
    (space?.build(modifier) ?? List()) +
    (display?.build(modifier) ?? List()) +
    (if (toggles?.build(modifier) == null) List() else List(toggles.build(modifier))) +
    (stack?.build(modifier) ?? List())

}
