module yabai

import "karabiner.pkl"
import "core.pkl"


cmdPath = "/opt/homebrew/bin/yabai"

open class YabaiMode {
  cmdPath = "/opt/homebrew/bin/yabai"
  actions = List("west", "south", "north", "east", "recent", "prev", "next", "first", "last")
  modifier: (List<karabiner.Modifier> | karabiner.Modifier | String)?
  mappings: Mapping<String, String> = new Mapping {}
  // mod: List<karabiner.Modifier> | karabiner.Modifier | String = modifier ?? super.mod
  action_cmd: String
  ignore = List("manipulators", "defined", "rules", "modifier", "mod", "action_cmd", "actions", "cmdPath", "ignore", "mappings")
  // mod: List<String?>? | String?  | Dynamic = trace(modifier) ?? trace(super.mod)

  function manipulators() = defined().entries.toMap((entry) -> entry.value, (entry) -> core.shell("\(cmdPath) \(action_cmd) \(entry.key)").single)
  function defined() = toMap().filter((key, val) -> !(ignore.contains(key) || val is Null)) + this.mappings.toMap()
  function rules() = if (manipulators().isEmpty) null else new core.SimLayer {trigger = modifier; maps = manipulators().toMapping()}.build().last
  function build(parentModifier: (String | List<String>)?): karabiner.Rule? = 
    let (effectiveModifier = modifier ?? parentModifier)
    if (manipulators().isEmpty || effectiveModifier == null) null
    else new core.SimLayer {trigger = effectiveModifier; maps = manipulators().toMapping()}.build().last
}

open class Sequential extends YabaiMode {
  prev: String?
  next: String?
  recent: String?
  first: String?
  last: String?
}

open class Directional extends YabaiMode {
  east: String?
  west: String?
  north: String?
  south: String?
  prev: String?
  next: String?
}

class WindowFocus extends Directional {
  mouse: String?
  action_cmd = "-m window --focus"
}

class WindowSwap extends Directional {
  action_cmd = "-m window --swap"
}

class WindowWarp extends Sequential {
  action_cmd = "-m window --warp"
}

class WindowResize extends Directional{
  action_cmd = "-m window --resize"
  left: String?
  down: String?
  up: String?
  right: String?
  topLeft: String?
  topRight: String?
  bottomLeft: String?
  bottomRight: String?
  increase: String?
  decrease: String?
  equalize: String?
  // amount: Int = 50
}

class WindowMoveFloat extends YabaiMode {
  action_cmd = "-m window --move"
  left: String?
  down: String?
  up: String?
  right: String?
  center: String?
  // amount: Int = 50
}

class WindowInsert extends Directional{
  action_cmd = "-m window --insert"
  stack: String?
  cancel: String?

}

class SpaceFocus extends Sequential {
  action_cmd = "-m space --focus"
}

class SpaceMove extends Sequential {
  action_cmd = "-m window --space"
}

class SpaceLayout extends YabaiMode {
  action_cmd = "-m space --layout"
  bsp: String?
  float: String?
  stack: String?
  balance: String?
  rotate: String?
  mirrorX: String?
  mirrorY: String?
}

class DisplayFocus extends Sequential {
  action_cmd = "-m display --focus"
}

class DisplayMove extends Sequential {
  action_cmd = "-m window --display"
}

class StackFocus extends Sequential {
  action_cmd = "-m window --focus stack"
}

class StackSwap extends Sequential {
  action_cmd = "-m window --swap stack"
}


open class YabaiFeature {
  modifier: (String|List<String>)?
  function rules() = toMap().fold(List(), (acc, k, v) -> if (k == "modifier" ||  v?.rules() is Null) acc else acc.add(v.rules()))
  function build(parentModifier: (String | List<String>)?): List<karabiner.Rule> = 
    let (effectiveModifier = modifier ?? parentModifier)
    toMap().fold(List(), (acc, k, v) -> 
      if (k == "modifier" || v == null) acc
      else if (v is YabaiMode) 
        let (rule = v.build(effectiveModifier))
        if (rule == null) acc else acc.add(rule)
      else if (v is YabaiFeature) acc + v.build(effectiveModifier)
      else acc
    )
}

class Window extends YabaiFeature {
  focus: WindowFocus?
  swap: WindowSwap?
  warp: WindowWarp?
  resize: WindowResize?
  moveFloat: WindowMoveFloat?
  insert: WindowInsert?

}

class Space extends YabaiFeature {
  focus: SpaceFocus?
  move: SpaceMove?
  layout: SpaceLayout?
}

class Display extends YabaiFeature {
  focus: DisplayFocus?
  move: DisplayMove?
}

class Toggles extends YabaiMode{
  action_cmd = "-m window --toggle"
  float: String?
  sticky: String?
  zoom: String?
  fullscreen: String?
  nativeFullscreen: String?
  split: String?
  minimize: String?
  gap: String?
  padding: String?
  topmost: String?
  pip: String?
  shadow: String?
  border: String?
  
  function build(parentModifier: (String | List<String>)?): karabiner.Rule? = 
    let (effectiveModifier = modifier ?? parentModifier)
    let (toggleMappings = defined().entries.toMap(
      (entry) -> entry.value,
      (entry) -> core.shell("\(cmdPath) -m window --toggle \(entry.key)").single
    ))
    if (toggleMappings.isEmpty || effectiveModifier == null) null
    else new core.SimLayer {trigger = effectiveModifier; maps = toggleMappings.toMapping()}.build().last
}

class Stack extends YabaiFeature {
  focus: StackFocus?
  swap: StackSwap?
}

class Yabai {
  modifier: (String | List<String>)? = null
  mod = modifier ?? ""
  cmdPath: String = "/opt/homebrew/bin/yabai"

  window: Window?
  space: Space?
  display: Display?
  toggles: Toggles?
  stack: Stack?

  build: List<karabiner.Rule> = 
    List(
      window?.build(modifier),
      space?.build(modifier),
      display?.build(modifier),
      toggles?.build(modifier),
      stack?.build(modifier)
    ).filterNonNull().flatten()

}
